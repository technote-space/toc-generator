"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const shell_escape_1 = __importDefault(require("shell-escape"));
/**
 * class CommandError
 */
class CommandError extends Error {
    /**
     * @param {string} message message
     * @param {number} code code
     */
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
/**
 * Command
 */
class Command {
    /**
     * @param {Logger} logger logger
     * @param {boolean} useExec use exec?
     */
    constructor(logger, useExec = false) {
        this.logger = logger;
        this.useExec = useExec;
        /**
         * @param {string} command command
         * @param {boolean} quiet quiet?
         * @param {boolean} suppressError suppress error?
         * @return {string} command
         */
        this.getCommand = (command, quiet, suppressError) => command + (quiet ? ' > /dev/null 2>&1' : '') + (suppressError ? ' || :' : '');
        /**
         * @param {string} command command
         * @param {string} altCommand alt command
         * @param {boolean} quiet quiet?
         * @param {ExecException} error error
         * @return {string} message
         */
        this.getRejectedErrorMessage = (command, altCommand, quiet, error) => {
            if ('string' === typeof altCommand) {
                if (!quiet) {
                    return `command [${altCommand}] exited with code ${error.code}. message: ${error.message}`;
                }
                else {
                    return `command [${altCommand}] exited with code ${error.code}.`;
                }
            }
            else if (!quiet) {
                return `command [${command}] exited with code ${error.code}. message: ${error.message}`;
            }
            return `command exited with code ${error.code}.`;
        };
        /**
         * @param {string} command command
         * @param {string|undefined} altCommand alt command
         * @param {boolean} stderrToStdout output to stdout instead of stderr
         * @param {string} stdout stdout
         * @param {string} stderr stderr
         * @return {object} command result
         */
        this.getCommandResult = (command, altCommand, stderrToStdout, stdout, stderr) => {
            let trimmedStdout = stdout.trim();
            let trimmedStderr = stderr.trim();
            if (trimmedStderr && stderrToStdout) {
                trimmedStdout += `\n${trimmedStderr}`;
                trimmedStderr = '';
            }
            return { stdout: trimmedStdout, stderr: trimmedStderr, command: 'string' === typeof altCommand ? altCommand : command };
        };
        /**
         * @param {string} stdout stdout
         * @param {boolean} quiet quiet?
         * @param {boolean} suppressOutput suppress output?
         */
        this.outputStdout = (stdout, quiet, suppressOutput) => {
            const trimmedStdout = stdout.trim();
            if (!quiet && !suppressOutput) {
                if (trimmedStdout) {
                    this.logger.displayStdout(trimmedStdout);
                }
            }
        };
        /**
         * @param {string} stderr stderr
         * @param {boolean} quiet quiet?
         * @param {boolean} suppressOutput suppress output?
         * @param {boolean} stderrToStdout output to stdout instead of stderr
         */
        this.outputStderr = (stderr, quiet, suppressOutput, stderrToStdout) => {
            const trimmedStderr = stderr.trim();
            if (!quiet && !suppressOutput) {
                if (trimmedStderr) {
                    if (stderrToStdout) {
                        this.logger.displayStdout(trimmedStderr);
                    }
                    else {
                        this.logger.displayStderr(trimmedStderr);
                    }
                }
            }
        };
        /**
         * @param {string} command command
         * @param {boolean} quiet quiet?
         * @param {boolean} suppressOutput suppress output?
         * @param {boolean} stderrToStdout output to stdout instead of stderr
         * @param {string|undefined} cwd cwd
         * @return {Promise<object>} output
         */
        this.execCommand = (command, quiet, suppressOutput, stderrToStdout, cwd) => {
            return new Promise((resolve, reject) => {
                const subProcess = child_process_1.spawn(command, [], { shell: true, cwd, stdio: [process.stdin, 'pipe', 'pipe'] });
                let stdout = '';
                let stderr = '';
                subProcess.stdout.on('data', (data) => {
                    this.outputStdout(data.toString(), quiet, suppressOutput);
                    stdout += data.toString();
                });
                subProcess.stderr.on('data', (data) => {
                    this.outputStderr(data.toString(), quiet, suppressOutput, stderrToStdout);
                    stderr += data.toString();
                });
                subProcess.on('error', (err) => {
                    reject(err);
                });
                subProcess.on('close', (code) => {
                    if (code) {
                        reject(new CommandError(stderr, code));
                    }
                    resolve({ stdout, stderr });
                });
            });
        };
        /**
         * @param {string} command command
         * @param {string|undefined} altCommand alt command
         * @param {boolean} quiet quiet?
         * @param {boolean} suppressOutput suppress output?
         * @param {boolean} stderrToStdout output to stdout instead of stderr
         * @param {function} resolve resolve
         * @param {function} reject reject
         * @return {void} void
         */
        this.execCallback = (command, altCommand, quiet, suppressOutput, stderrToStdout, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        resolve, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        reject) => (error, stdout, stderr) => {
            if (error) {
                reject(new Error(this.getRejectedErrorMessage(command, altCommand, quiet, error)));
            }
            else {
                let trimmedStdout = stdout.trim();
                let trimmedStderr = stderr.trim();
                if (!quiet && !suppressOutput) {
                    if (trimmedStdout) {
                        this.logger.displayStdout(trimmedStdout);
                    }
                    if (trimmedStderr) {
                        if (stderrToStdout) {
                            this.logger.displayStdout(trimmedStderr);
                            trimmedStdout += `\n${trimmedStderr}`;
                            trimmedStderr = '';
                        }
                        else {
                            this.logger.displayStderr(trimmedStderr);
                        }
                    }
                }
                resolve({ stdout: trimmedStdout, stderr: trimmedStderr, command: 'string' === typeof altCommand ? altCommand : command });
            }
        };
        /**
         * @param {object} options options
         * @param {string} options.command command
         * @param {string[]|undefined} options.args command
         * @param {string|undefined} options.cwd cwd
         * @param {boolean|undefined} options.quiet quiet?
         * @param {string|undefined} options.altCommand alt command
         * @param {boolean|undefined} options.suppressError suppress error?
         * @param {boolean|undefined} options.suppressOutput suppress output?
         * @param {boolean|undefined} options.stderrToStdout output to stdout instead of stderr
         * @return {Promise<object>} output
         */
        this.execAsync = async (options) => {
            const { command, args, cwd, altCommand, quiet = false, suppressError = false, suppressOutput = false, stderrToStdout = false } = options;
            const commandArgs = undefined === args ? '' : shell_escape_1.default(args.map(item => item.trim()).filter(item => item.length));
            const commandWithArgs = command + (commandArgs.length ? ' ' + commandArgs : '');
            if (undefined !== altCommand) {
                if (altCommand) {
                    this.logger.displayCommand(altCommand);
                }
            }
            else if (!quiet) {
                this.logger.displayCommand(commandWithArgs);
            }
            if (this.useExec) {
                return new Promise((resolve, reject) => {
                    if (typeof cwd === 'undefined') {
                        child_process_1.exec(this.getCommand(commandWithArgs, quiet, suppressError), this.execCallback(commandWithArgs, altCommand, quiet, suppressOutput, stderrToStdout, resolve, reject));
                    }
                    else {
                        child_process_1.exec(this.getCommand(commandWithArgs, quiet, suppressError), { cwd }, this.execCallback(commandWithArgs, altCommand, quiet, suppressOutput, stderrToStdout, resolve, reject));
                    }
                });
            }
            else {
                try {
                    const { stdout, stderr } = await this.execCommand(this.getCommand(commandWithArgs, quiet, suppressError), quiet, suppressOutput, stderrToStdout, cwd);
                    return this.getCommandResult(commandWithArgs, altCommand, stderrToStdout, stdout, stderr);
                }
                catch (error) {
                    throw new Error(this.getRejectedErrorMessage(command, altCommand, quiet, error));
                }
            }
        };
    }
}
exports.default = Command;

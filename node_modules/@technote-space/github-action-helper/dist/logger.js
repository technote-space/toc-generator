"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const sprintf_js_1 = require("sprintf-js");
const core_1 = require("@actions/core");
const utils_1 = require("./utils");
const COLOR_MAP = {
    'black': 0,
    'red': 1,
    'green': 2,
    'yellow': 3,
    'blue': 4,
    'magenta': 5,
    'cyan': 6,
    'white': 7,
};
const ATTRIBUTE_MAP = {
    'none': 0,
    'bold': 1,
    'underline': 4,
    'italic': 3,
};
/**
 * Logger
 */
let Logger = /** @class */ (() => {
    class Logger {
        /**
         * @param {function|undefined} replacer replacer
         * @param {boolean} notUseGroup not use group?
         */
        constructor(replacer, notUseGroup = false) {
            this.notUseGroup = notUseGroup;
            /**
             * @param {string} message message
             * @return {string[]} messages
             */
            this.splitMessage = (message) => utils_1.split(message.replace(/\r?\n$/, ''));
            /**
             * @param {string} message message
             * @param {any[]} args args
             * @return {string} output string
             */
            this.getOutputString = (message, ...args) => args.length ? sprintf_js_1.sprintf(this.replacer(message), ...args.map(arg => 'string' === typeof arg ? this.replacer(arg) : arg)) : this.replacer(message);
            /**
             * @param {function} output output function
             * @param {function|null} replacer replacer
             * @param {string|string[]} message message
             * @param {any[]} args args
             */
            this.multiLineOutput = (output, replacer, message, ...args) => {
                if (!message) {
                    output('');
                    return;
                }
                if ('string' !== typeof message) {
                    message.forEach(message => {
                        this.multiLineOutput(output, replacer, message, ...args);
                    });
                    return;
                }
                this.splitMessage(message).forEach(message => output(this.getOutputString(replacer ? replacer(message) : message, ...args)));
            };
            /**
             * @param {string|string[]} message message
             * @param {any[]} args args
             * @return {void}
             */
            this.log = (message, ...args) => this.multiLineOutput(core_1.info, null, message, ...args);
            /**
             * @param {string|string[]} message message
             * @param {any[]} args args
             * @return {void}
             */
            this.info = (message, ...args) => this.multiLineOutput(core_1.info, message => `> ${message}`, message, ...args);
            /**
             * @param {string|string[]} message message
             * @param {any[]} args args
             * @return {void}
             */
            this.debug = (message, ...args) => this.multiLineOutput(core_1.debug, null, message, ...args);
            /**
             * @param {string|string[]} message message
             * @param {any[]} args args
             * @return {void}
             */
            this.error = (message, ...args) => this.multiLineOutput(core_1.error, null, message, ...args);
            /**
             * @param {string|string[]} message message
             * @param {any[]} args args
             * @return {void}
             */
            this.warn = (message, ...args) => this.multiLineOutput(core_1.warning, null, message, ...args);
            /**
             * @param {string|string[]} message message
             * @param {any[]} args args
             * @return {void}
             */
            this.displayCommand = (message, ...args) => this.multiLineOutput(core_1.info, message => `[command]${message}`, message, ...args);
            /**
             * @param {string|string[]} message message
             * @return {void}
             */
            this.displayStdout = (message) => this.multiLineOutput(core_1.info, message => `  >> ${message}`, message);
            /**
             * @param {string|string[]} message message
             * @return {void}
             */
            this.displayStderr = (message) => this.multiLineOutput(core_1.warning, message => `  >> ${message}`, message);
            /**
             * @param {string} message message
             * @param {any[]} args args
             * @return {void}
             */
            this.startProcess = (message, ...args) => {
                if (this.notUseGroup) {
                    this.info(message, ...args);
                    return;
                }
                this.endProcess();
                core_1.startGroup(this.getOutputString(message, ...args));
                Logger.isRequiredEndGroup = true;
            };
            /**
             * @return {void}
             */
            this.endProcess = () => {
                if (this.notUseGroup) {
                    return;
                }
                if (Logger.isRequiredEndGroup) {
                    core_1.endGroup();
                    Logger.isRequiredEndGroup = false;
                }
            };
            /**
             * @param {string} string string
             * @param {Setting|undefined} setting setting
             * @return {string} color string
             */
            this.getColorString = (string, setting) => { var _a, _b, _c; return sprintf_js_1.sprintf('\x1b[3%d;4%d;%dm%s\x1b[0m', COLOR_MAP[(_a = setting === null || setting === void 0 ? void 0 : setting.color) !== null && _a !== void 0 ? _a : 'white'], COLOR_MAP[(_b = setting === null || setting === void 0 ? void 0 : setting.backColor) !== null && _b !== void 0 ? _b : 'black'], ATTRIBUTE_MAP[(_c = setting === null || setting === void 0 ? void 0 : setting.attribute) !== null && _c !== void 0 ? _c : 'none'], string); };
            /**
             * @param {string} string string
             * @param {Setting|undefined} setting setting
             * @return {string} color string
             */
            this.c = (string, setting) => this.getColorString(string, setting);
            this.replacer = replacer ? replacer : (text) => text;
        }
    }
    Logger.isRequiredEndGroup = false;
    /**
     * @return {void}
     */
    Logger.resetForTesting = () => {
        Logger.isRequiredEndGroup = false;
    };
    return Logger;
})();
exports.default = Logger;

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureNotNull = exports.ensureNotNullValue = exports.objectGet = exports.isOutputDebug = exports.isCommandDebug = exports.replaceVariables = exports.mask = exports.versionCompare = exports.arrayChunk = exports.generateNewMajorVersion = exports.generateNewMinorVersion = exports.generateNewPatchVersion = exports.generateNewVersion = exports.replaceAll = exports.useNpm = exports.sleep = exports.getArrayInput = exports.split = exports.getWorkspace = exports.uniqueArray = exports.getBoolValue = exports.getSuffixRegExp = exports.getPrefixRegExp = exports.getRegExp = exports.escapeRegExp = exports.getActor = exports.getOctokit = exports.getAccessToken = exports.getRefspec = exports.getLocalRefspec = exports.getRemoteRefspec = exports.getTag = exports.trimRef = exports.normalizeRef = exports.getPrBranch = exports.getBranch = exports.getRefForUpdate = exports.getPrHeadRef = exports.getPrMergeRef = exports.isPrRef = exports.isRemoteBranch = exports.isTagRef = exports.isBranch = exports.isRef = exports.isSemanticVersioningTagName = exports.isValidSemanticVersioning = exports.normalizeVersion = exports.parseVersion = exports.isCloned = exports.getBuildInfo = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("@actions/core");
const github_1 = require("@actions/github");
const getRef = (ref) => typeof ref === 'string' ? ref : ref.ref;
const getBuildInfo = (filepath) => {
    if (!fs_1.default.existsSync(filepath)) {
        return false;
    }
    try {
        return JSON.parse(fs_1.default.readFileSync(filepath, 'utf8'));
    }
    catch {
        return false;
    }
};
exports.getBuildInfo = getBuildInfo;
const isCloned = (workDir) => fs_1.default.existsSync(path_1.default.resolve(workDir, '.git'));
exports.isCloned = isCloned;
const parseVersion = (version, options) => {
    var _a, _b, _c, _d, _e;
    // https://semver.org/spec/v2.0.0.html
    const regex = (options === null || options === void 0 ? void 0 : options.strict) ?
        /^[vV]?((0|[1-9]\d*)(\.(0|[1-9]\d*)){2})(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/ :
        /^[vV]?((0|[1-9]\d*)(\.(0|[1-9]\d*))*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
    const matches = version.trim().replace(/^[=v]+/, '').match(regex);
    if (!matches) {
        return undefined;
    }
    const fragments = exports.split(matches[1], '.');
    // eslint-disable-next-line no-magic-numbers
    const length = (options === null || options === void 0 ? void 0 : options.slice) && options.slice < 0 ? ((_a = options.length) !== null && _a !== void 0 ? _a : 3) : ((_c = (_b = options === null || options === void 0 ? void 0 : options.slice) !== null && _b !== void 0 ? _b : options === null || options === void 0 ? void 0 : options.length) !== null && _c !== void 0 ? _c : 3);
    // eslint-disable-next-line no-magic-numbers
    while ((options === null || options === void 0 ? void 0 : options.fill) !== false && fragments.length < length) {
        fragments.push('0');
    }
    return {
        // eslint-disable-next-line no-magic-numbers
        core: ((options === null || options === void 0 ? void 0 : options.cut) === false ? fragments : fragments.slice(0, (_e = (_d = options === null || options === void 0 ? void 0 : options.slice) !== null && _d !== void 0 ? _d : options === null || options === void 0 ? void 0 : options.length) !== null && _e !== void 0 ? _e : 3)).join('.'),
        preRelease: matches[5],
        build: matches[6],
        fragments,
    };
};
exports.parseVersion = parseVersion;
const normalizeVersion = (version, options) => {
    const parsed = exports.parseVersion(version, options);
    if (!parsed) {
        return options === null || options === void 0 ? void 0 : options.fallback;
    }
    if (options === null || options === void 0 ? void 0 : options.onlyCore) {
        return parsed.core;
    }
    return parsed.core + (parsed.preRelease ? `-${parsed.preRelease}` : '') + (parsed.build ? `+${parsed.build}` : '');
};
exports.normalizeVersion = normalizeVersion;
const isValidSemanticVersioning = (version, strict) => exports.parseVersion(version, { strict }) !== undefined;
exports.isValidSemanticVersioning = isValidSemanticVersioning;
/* istanbul ignore next */
/*
 * @deprecated Use isValidSemanticVersioning
 */
const isSemanticVersioningTagName = (tagName) => /^v?\d+(\.\d+)*$/i.test(tagName);
exports.isSemanticVersioningTagName = isSemanticVersioningTagName;
const isRef = (ref) => /^refs\//.test(getRef(ref));
exports.isRef = isRef;
const isBranch = (ref) => /^refs\/heads\//.test(getRef(ref));
exports.isBranch = isBranch;
const isTagRef = (ref) => /^refs\/tags\//.test(getRef(ref));
exports.isTagRef = isTagRef;
const isRemoteBranch = (ref) => /^refs\/remotes\/origin\//.test(getRef(ref));
exports.isRemoteBranch = isRemoteBranch;
const isPrRef = (ref) => /^refs\/pull\/\d+\/(merge|head)$/.test(getRef(ref));
exports.isPrRef = isPrRef;
const getPrMergeRef = (ref) => getRef(ref).replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/merge');
exports.getPrMergeRef = getPrMergeRef;
const getPrHeadRef = (ref) => getRef(ref).replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/head');
exports.getPrHeadRef = getPrHeadRef;
const getRefForUpdate = (ref) => getRef(ref).replace(/^refs\//, '');
exports.getRefForUpdate = getRefForUpdate;
const getBranch = (ref, defaultIsEmpty = true) => exports.isBranch(ref) ?
    getRef(ref).replace(/^refs\/heads\//, '') :
    (exports.isRemoteBranch(ref) ? getRef(ref).replace(/^refs\/remotes\/origin\//, '') :
        (defaultIsEmpty ? '' : exports.getRefForUpdate(ref)));
exports.getBranch = getBranch;
const getPrBranch = (context) => { var _a, _b; return (_b = (_a = context.payload.pull_request) === null || _a === void 0 ? void 0 : _a.head.ref) !== null && _b !== void 0 ? _b : ''; };
exports.getPrBranch = getPrBranch;
const normalizeRef = (ref) => exports.isRef(ref) ? getRef(ref) : `refs/heads/${getRef(ref)}`;
exports.normalizeRef = normalizeRef;
const trimRef = (ref) => getRef(ref).replace(/^refs\/(heads|tags|pull)\//, '');
exports.trimRef = trimRef;
const getTag = (ref) => exports.isTagRef(ref) ? exports.trimRef(ref) : '';
exports.getTag = getTag;
const saveTarget = (ref, origin) => exports.isTagRef(ref) ? 'tags' : exports.isPrRef(ref) ? `${origin}/pull` : origin;
// e.g.
//  refs/heads/master
//  refs/pull/123/merge
//  refs/tags/v1.2.3
const getRemoteRefspec = (ref) => exports.normalizeRef(ref);
exports.getRemoteRefspec = getRemoteRefspec;
// e.g.
//  origin/master
//  origin/pull/123/merge
//  tags/v1.2.3
const getLocalRefspec = (ref, origin = 'origin') => `${saveTarget(ref, origin)}/${exports.trimRef(ref)}`;
exports.getLocalRefspec = getLocalRefspec;
// e.g.
//  refs/heads/master:refs/remotes/origin/master
//  refs/pull/123/merge:refs/pull/123/merge
//  refs/tags/v1.2.3:refs/tags/v1.2.3
const getRefspec = (ref, origin = 'origin') => `${exports.getRemoteRefspec(ref)}:refs/${exports.getLocalRefspec(ref, `remotes/${origin}`)}`;
exports.getRefspec = getRefspec;
const getAccessToken = (required) => core_1.getInput('GITHUB_TOKEN', { required });
exports.getAccessToken = getAccessToken;
const getOctokit = (token) => github_1.getOctokit(token !== null && token !== void 0 ? token : exports.getAccessToken(true), {});
exports.getOctokit = getOctokit;
const getActor = () => process.env.GITHUB_ACTOR || '';
exports.getActor = getActor;
const escapeRegExp = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
exports.escapeRegExp = escapeRegExp;
const getRegExp = (value) => new RegExp(exports.escapeRegExp(value));
exports.getRegExp = getRegExp;
const getPrefixRegExp = (value, flags = '') => new RegExp('^' + exports.escapeRegExp(value), flags);
exports.getPrefixRegExp = getPrefixRegExp;
const getSuffixRegExp = (value, flags = '') => new RegExp(exports.escapeRegExp(value) + '$', flags);
exports.getSuffixRegExp = getSuffixRegExp;
const getBoolValue = (input) => !['false', '0', '', 'no', 'n'].includes(input.trim().toLowerCase());
exports.getBoolValue = getBoolValue;
const uniqueArray = (array) => [...new Set(array)];
exports.uniqueArray = uniqueArray;
const getWorkspace = () => process.env.GITHUB_WORKSPACE || '';
exports.getWorkspace = getWorkspace;
const split = (value, separator = /\r?\n/, limit) => value.length ? value.split(separator, limit) : [];
exports.split = split;
const getArrayInput = (name, required = false, separator = ',', unique = true) => {
    const arrayInput = core_1.getInput(name, { required }).split(/\r?\n/).reduce((acc, line) => acc.concat(separator ? line.split(separator) : line).filter(item => item).map(item => item.trim()), []);
    return unique ? exports.uniqueArray(arrayInput) : arrayInput;
};
exports.getArrayInput = getArrayInput;
const sleep = async (millisecond) => new Promise(resolve => setTimeout(resolve, millisecond));
exports.sleep = sleep;
const useNpm = (workDir, pkgManager = '') => 'npm' === pkgManager ||
    ('yarn' !== pkgManager && (fs_1.default.existsSync(path_1.default.resolve(workDir, 'package-lock.json')) ||
        !fs_1.default.existsSync(path_1.default.resolve(workDir, 'yarn.lock'))));
exports.useNpm = useNpm;
const replaceAll = (string, key, value) => string.split(key).join(value);
exports.replaceAll = replaceAll;
const generateNewVersion = (lastTag, position) => {
    const parsed = exports.parseVersion(lastTag);
    if (!parsed) {
        throw new Error('Invalid versioning');
    }
    const target = Math.max(Math.min(position !== null && position !== void 0 ? position : 2, 2), 0); // eslint-disable-line no-magic-numbers
    parsed.fragments[target] = (Number(parsed.fragments[target]) + 1).toString(); // eslint-disable-line no-magic-numbers
    [...Array(2 - target).keys()].forEach(key => parsed.fragments[2 - key] = '0'); // eslint-disable-line no-magic-numbers
    return 'v' + parsed.fragments.slice(0, 3).join('.'); // eslint-disable-line no-magic-numbers
};
exports.generateNewVersion = generateNewVersion;
const generateNewPatchVersion = (lastTag) => exports.generateNewVersion(lastTag);
exports.generateNewPatchVersion = generateNewPatchVersion;
const generateNewMinorVersion = (lastTag) => exports.generateNewVersion(lastTag, 1); // eslint-disable-line no-magic-numbers
exports.generateNewMinorVersion = generateNewMinorVersion;
const generateNewMajorVersion = (lastTag) => exports.generateNewVersion(lastTag, 0); // eslint-disable-line no-magic-numbers
exports.generateNewMajorVersion = generateNewMajorVersion;
// eslint-disable-next-line no-magic-numbers
const arrayChunk = (array, size = 100) => {
    const result = [];
    const length = array.length;
    for (let index = 0; index < length; index += size) {
        result.push(array.slice(index, index + size));
    }
    return result;
};
exports.arrayChunk = arrayChunk;
const versionCompare = (version1, version2, checkDifferentLevel = true) => {
    const splitVersion = (version) => version.split('.').map(item => Number(item));
    // eslint-disable-next-line no-magic-numbers
    const compare = (version1, version2, num = 0) => {
        var _a, _b;
        if (version1.length <= num && version2.length <= num) {
            // eslint-disable-next-line no-magic-numbers
            return checkDifferentLevel ? Math.sign(version1.length - version2.length) : 0;
        }
        // eslint-disable-next-line no-magic-numbers
        const val1 = (_a = version1[num]) !== null && _a !== void 0 ? _a : (checkDifferentLevel ? 0 : version2[num]);
        // eslint-disable-next-line no-magic-numbers
        const val2 = (_b = version2[num]) !== null && _b !== void 0 ? _b : (checkDifferentLevel ? 0 : version1[num]);
        return val1 === val2 ? compare(version1, version2, ++num) : Math.sign(val1 - val2);
    };
    return compare(splitVersion(version1.replace(/^v/, '')), splitVersion(version2.replace(/^v/, '')));
};
exports.versionCompare = versionCompare;
// eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/explicit-module-boundary-types
const mask = (value, target = 'token') => {
    Object.keys(value).forEach(key => {
        if (value[key] && typeof value[key] === 'object') {
            value[key] = exports.mask(value[key], target);
        }
        else if (target === key) {
            value[key] = '***';
        }
    });
    return value;
};
exports.mask = mask;
const replaceVariables = async (string, variables) => {
    let replaced = string;
    for (const variable of variables) {
        if (exports.getRegExp(`\${${variable.key}}`).test(replaced)) {
            if (typeof variable.replace === 'string') {
                replaced = exports.replaceAll(replaced, `\${${variable.key}}`, variable.replace);
            }
            else {
                replaced = exports.replaceAll(replaced, `\${${variable.key}}`, await variable.replace());
            }
        }
    }
    return replaced;
};
exports.replaceVariables = replaceVariables;
const isCommandDebug = () => core_1.getInput('UTILS_COMMAND_DEBUG') === 'true' || process.env.UTILS_COMMAND_DEBUG === 'true';
exports.isCommandDebug = isCommandDebug;
const isOutputDebug = () => core_1.getInput('UTILS_OUTPUT_DEBUG') === 'true' || process.env.UTILS_OUTPUT_DEBUG === 'true';
exports.isOutputDebug = isOutputDebug;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const objectGet = (value, key, defaultValue) => {
    const keys = key.split('.');
    if (!keys.length || !value || !(keys[0] in value)) {
        return defaultValue;
    }
    // eslint-disable-next-line no-magic-numbers
    if (keys.length > 1) {
        // eslint-disable-next-line no-magic-numbers
        return exports.objectGet(value[keys[0]], keys.slice(1).join('.'), defaultValue);
    }
    return value[keys[0]];
};
exports.objectGet = objectGet;
const ensureNotNullValue = (value, defaultValue) => value !== null && value !== void 0 ? value : defaultValue;
exports.ensureNotNullValue = ensureNotNullValue;
const ensureNotNull = (value) => exports.ensureNotNullValue(value, '');
exports.ensureNotNull = ensureNotNull;

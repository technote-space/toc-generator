"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("@actions/core");
const github_1 = require("@actions/github");
const getRef = (ref) => typeof ref === 'string' ? ref : ref.ref;
exports.getBuildInfo = (filepath) => {
    if (!fs_1.default.existsSync(filepath)) {
        return false;
    }
    try {
        return JSON.parse(fs_1.default.readFileSync(filepath, 'utf8'));
    }
    catch (_a) {
        return false;
    }
};
exports.isCloned = (workDir) => fs_1.default.existsSync(path_1.default.resolve(workDir, '.git'));
exports.isSemanticVersioningTagName = (tagName) => /^v?\d+(\.\d+)*$/i.test(tagName);
exports.isBranch = (ref) => /^(refs\/)?heads\//.test(getRef(ref));
exports.isTagRef = (ref) => /^refs\/?tags\//.test(getRef(ref));
exports.isRemoteBranch = (ref) => /^(refs\/)?remotes\/origin\//.test(getRef(ref));
exports.isPrRef = (ref) => /^refs\/pull\/\d+\/(merge|head)$/.test(getRef(ref));
exports.getPrMergeRef = (ref) => getRef(ref).replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/merge');
exports.getPrHeadRef = (ref) => getRef(ref).replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/head');
exports.getRefForUpdate = (ref) => getRef(ref).replace(/^refs\//, '');
exports.getBranch = (ref, defaultIsEmpty = true) => exports.isBranch(ref) ?
    getRef(ref).replace(/^(refs\/)?heads\//, '') :
    (exports.isRemoteBranch(ref) ? getRef(ref).replace(/^(refs\/)?remotes\/origin\//, '') :
        (defaultIsEmpty ? '' : exports.getRefForUpdate(ref)));
exports.getPrBranch = (context) => { var _a, _b; return _b = (_a = context.payload.pull_request) === null || _a === void 0 ? void 0 : _a.head.ref, (_b !== null && _b !== void 0 ? _b : ''); };
exports.normalizeRef = (ref) => /^refs\//.test(getRef(ref)) ? getRef(ref) : `refs/heads/${getRef(ref)}`;
exports.trimRef = (ref) => getRef(ref).replace(/^refs\/(heads|tags|pull)\//, '');
exports.getTag = (ref) => exports.isTagRef(ref) ? exports.trimRef(ref) : '';
const saveTarget = (ref, origin) => exports.isTagRef(ref) ? 'tags' : exports.isPrRef(ref) ? 'pull' : `remotes/${origin}`;
exports.getRefspec = (ref, origin = 'origin') => `${exports.normalizeRef(ref)}:refs/${saveTarget(ref, origin)}/${exports.trimRef(ref)}`;
exports.getAccessToken = (required) => core_1.getInput('GITHUB_TOKEN', { required });
// eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
exports.getOctokit = (token) => new github_1.GitHub((token !== null && token !== void 0 ? token : exports.getAccessToken(true)), {
    log: {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        warn: function () {
        },
    },
});
exports.getActor = () => process.env.GITHUB_ACTOR || '';
exports.escapeRegExp = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
exports.getRegExp = (value) => new RegExp(exports.escapeRegExp(value));
exports.getPrefixRegExp = (value) => new RegExp('^' + exports.escapeRegExp(value));
exports.getSuffixRegExp = (value) => new RegExp(exports.escapeRegExp(value) + '$');
exports.getBoolValue = (input) => !['false', '0', '', 'no', 'n'].includes(input.trim().toLowerCase());
exports.uniqueArray = (array) => [...new Set(array)];
exports.getWorkspace = () => process.env.GITHUB_WORKSPACE || '';
exports.split = (value, separator = /\r?\n/, limit) => value.length ? value.split(separator, limit) : [];
exports.getArrayInput = (name, required = false, separator = ',', unique = true) => {
    const arrayInput = core_1.getInput(name, { required }).split(/\r?\n/).reduce((acc, line) => acc.concat(separator ? line.split(separator) : line).filter(item => item).map(item => item.trim()), []);
    return unique ? exports.uniqueArray(arrayInput) : arrayInput;
};
exports.sleep = (millisecond) => __awaiter(void 0, void 0, void 0, function* () { return new Promise(resolve => setTimeout(resolve, millisecond)); });
exports.useNpm = (workDir, pkgManager = '') => 'npm' === pkgManager ||
    ('yarn' !== pkgManager && (fs_1.default.existsSync(path_1.default.resolve(workDir, 'package-lock.json')) ||
        !fs_1.default.existsSync(path_1.default.resolve(workDir, 'yarn.lock'))));
exports.replaceAll = (string, key, value) => string.split(key).join(value);
exports.generateNewPatchVersion = (lastTag) => {
    if (!/^v?\d+(\.\d+)*$/.test(lastTag)) {
        throw new Error('Invalid tag');
    }
    const fragments = exports.split(lastTag.replace(/^v/, ''), '.');
    // eslint-disable-next-line no-magic-numbers
    while (fragments.length < 3) {
        fragments.push('0');
    }
    // eslint-disable-next-line no-magic-numbers
    fragments[fragments.length - 1] = (Number(fragments[fragments.length - 1]) + 1).toString();
    return 'v' + fragments.join('.');
};
// eslint-disable-next-line no-magic-numbers
exports.arrayChunk = (array, size = 100) => {
    const result = [], length = array.length;
    for (let index = 0; index < length; index += size) {
        result.push(array.slice(index, index + size));
    }
    return result;
};
exports.versionCompare = (version1, version2, checkDifferentLevel = true) => {
    const splitVersion = (version) => version.split('.').map(item => Number(item));
    // eslint-disable-next-line no-magic-numbers
    const compare = (version1, version2, num = 0) => {
        var _a, _b;
        if (version1.length <= num && version2.length <= num) {
            // eslint-disable-next-line no-magic-numbers
            return checkDifferentLevel ? Math.sign(version1.length - version2.length) : 0;
        }
        // eslint-disable-next-line no-magic-numbers
        const val1 = (_a = version1[num], (_a !== null && _a !== void 0 ? _a : (checkDifferentLevel ? 0 : version2[num]))), val2 = (_b = version2[num], (_b !== null && _b !== void 0 ? _b : (checkDifferentLevel ? 0 : version1[num])));
        return val1 === val2 ? compare(version1, version2, ++num) : Math.sign(val1 - val2);
    };
    return compare(splitVersion(version1.replace(/^v/, '')), splitVersion(version2.replace(/^v/, '')));
};

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("@actions/core");
const utils_1 = require("./utils");
const context_helper_1 = require("./context-helper");
/**
 * API Helper
 */
class ApiHelper {
    /**
     * @param {Octokit} octokit octokit
     * @param {Context} context context
     * @param {Logger} logger logger
     * @param {object} options options
     * @param {string|undefined} options.branch branch
     * @param {string|undefined} options.sender sender
     * @param {string|undefined} options.refForUpdate ref for update
     * @param {boolean|undefined} options.suppressBPError suppress branch protection error?
     */
    constructor(octokit, context, logger, options) {
        this.octokit = octokit;
        this.context = context;
        this.logger = logger;
        this.branch = undefined;
        this.sender = undefined;
        this.suppressBPError = undefined;
        this.refForUpdate = undefined;
        this.prCache = {};
        /**
         * @param {function} caller caller
         */
        this.callLogger = (caller) => {
            if (this.logger) {
                caller(this.logger);
            }
        };
        /**
         * @return {string|boolean} sender
         */
        this.getSender = () => this.sender ? this.sender : context_helper_1.getSender(this.context);
        /**
         * @param {boolean} encode encode?
         * @return {string} ref for update
         */
        this.getRefForUpdate = (encode) => __awaiter(this, void 0, void 0, function* () {
            const ref = this.refForUpdate ? this.refForUpdate : (utils_1.isPrRef(this.context) ? ('heads/' + (yield this.getPR()).data.head.ref) : utils_1.getRefForUpdate(this.context));
            return encode ? encodeURIComponent(ref) : ref;
        });
        /**
         * @param {string} rootDir root dir
         * @param {string} filepath filepath
         * @return {Promise<{ path: string, sha: string }>} blob
         */
        this.createBlob = (rootDir, filepath) => __awaiter(this, void 0, void 0, function* () {
            const blob = yield this.octokit.git.createBlob(Object.assign(Object.assign({}, this.context.repo), { content: Buffer.from(fs_1.default.readFileSync(path_1.default.resolve(rootDir, filepath), 'utf8')).toString('base64'), encoding: 'base64' }));
            return {
                path: filepath,
                sha: blob.data.sha,
            };
        });
        /**
         * @return {string} commit sha
         */
        this.getCommitSha = () => utils_1.isPrRef(this.context) && this.context.payload.pull_request ? this.context.payload.pull_request.head.sha : this.context.sha;
        /**
         * @return {Promise<Octokit.Response<Octokit.GitGetCommitResponse>>} commit
         */
        this.getCommit = () => __awaiter(this, void 0, void 0, function* () {
            return this.octokit.git.getCommit(Object.assign(Object.assign({}, this.context.repo), { 'commit_sha': this.getCommitSha() }));
        });
        /**
         * @return {Promise<Octokit.Response<Octokit.PullsGetResponse>>} commit
         */
        this.getPR = () => __awaiter(this, void 0, void 0, function* () {
            const key = parseInt(this.context.payload.number, 10);
            if (!(key in this.prCache)) {
                this.prCache[key] = yield this.octokit.pulls.get(Object.assign(Object.assign({}, this.context.repo), { 'pull_number': this.context.payload.number }));
            }
            return this.prCache[key];
        });
        /**
         * @param {string} rootDir root dir
         * @param {object} files files
         * @return {Promise<{ path: string, sha: string }[]>} blobs
         */
        this.filesToBlobs = (rootDir, files) => __awaiter(this, void 0, void 0, function* () { return yield Promise.all(Object.values(files).map(file => this.createBlob(rootDir, file))); });
        /**
         * @param {{ path: string, sha: string }[]} blobs blobs
         * @return {Promise<Octokit.Response<Octokit.GitCreateTreeResponse>>} tree
         */
        this.createTree = (blobs) => __awaiter(this, void 0, void 0, function* () {
            return this.octokit.git.createTree(Object.assign(Object.assign({}, this.context.repo), { 'base_tree': (yield this.getCommit()).data.tree.sha, tree: Object.values(blobs).map(blob => ({
                    path: blob.path,
                    type: 'blob',
                    mode: '100644',
                    sha: blob.sha,
                })) }));
        });
        /**
         * @param {string} commitMessage commit message
         * @param {Octokit.Response<Octokit.GitCreateTreeResponse>} tree tree
         * @return {Promise<Octokit.Response<Octokit.GitCreateCommitResponse>>} commit
         */
        this.createCommit = (commitMessage, tree) => __awaiter(this, void 0, void 0, function* () {
            return this.octokit.git.createCommit(Object.assign(Object.assign({}, this.context.repo), { tree: tree.data.sha, parents: [this.getCommitSha()], message: commitMessage }));
        });
        /**
         * @param {string} refName refName
         * @return {Promise<Octokit.AnyResponse|null>} refName
         */
        this.getRef = (refName) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.octokit.git.getRef(Object.assign(Object.assign({}, this.context.repo), { ref: refName }));
            }
            catch (error) {
                return null;
            }
        });
        /**
         * @param {Octokit.Response<Octokit.GitCreateCommitResponse>} commit commit
         * @param {string} refName refName
         * @param {boolean} force force
         * @return {Promise<void>} void
         */
        this.updateRef = (commit, refName, force) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.octokit.git.updateRef(Object.assign(Object.assign({}, this.context.repo), { ref: refName, sha: commit.data.sha, force }));
                return true;
            }
            catch (error) {
                if (this.suppressBPError === true && this.isProtectedBranchError(error)) {
                    this.callLogger(logger => logger.warn('Branch is protected.'));
                }
                else {
                    throw error;
                }
                return false;
            }
        });
        /**
         * @param {Octokit.Response<Octokit.GitCreateCommitResponse>} commit commit
         * @param {string} refName refName
         * @return {Promise<void>} void
         */
        this.createRef = (commit, refName) => __awaiter(this, void 0, void 0, function* () {
            yield this.octokit.git.createRef(Object.assign(Object.assign({}, this.context.repo), { ref: refName, sha: commit.data.sha }));
        });
        /**
         * @param {string} refName refName
         * @return {Promise<void>} void
         */
        this.deleteRef = (refName) => __awaiter(this, void 0, void 0, function* () {
            yield this.octokit.git.deleteRef(Object.assign(Object.assign({}, this.context.repo), { ref: refName }));
        });
        /**
         * @param {string} branchName branch name
         * @return {Promise<Octokit.PullsListResponseItem>} pull request
         */
        this.findPullRequest = (branchName) => __awaiter(this, void 0, void 0, function* () {
            const response = yield this.octokit.pulls.list(Object.assign(Object.assign({}, this.context.repo), { head: `${this.context.repo.owner}:${utils_1.getBranch(branchName, false)}` }));
            if (response.data.length) {
                return response.data[0];
            }
            return null;
        });
        /**
         * @param {PullsListParams} params params
         * @return {AsyncIterable<Octokit.PullsListResponseItem>} pull request list
         */
        this.pullsList = (params) => this.octokit.paginate(this.octokit.pulls.list.endpoint.merge(Object.assign({
            sort: 'created',
            direction: 'asc',
        }, params, Object.assign({}, this.context.repo))));
        /**
         * @param {string} branchName branch name
         * @param {PullsCreateParams} detail detail
         * @return {Promise<Octokit.Response<Octokit.PullsCreateResponse>>} pull
         */
        this.pullsCreate = (branchName, detail) => __awaiter(this, void 0, void 0, function* () {
            return this.octokit.pulls.create(Object.assign(Object.assign(Object.assign({}, this.context.repo), { head: `${this.context.repo.owner}:${utils_1.getBranch(branchName, false)}`, base: (yield this.getRefForUpdate(false)).replace(/^heads\//, '') }), detail));
        });
        /**
         * @param {number} number pull number
         * @param {PullsUpdateParams} detail detail
         * @return {Promise<Octokit.Response<Octokit.PullsUpdateResponse>>} pull
         */
        this.pullsUpdate = (number, detail) => __awaiter(this, void 0, void 0, function* () {
            return this.octokit.pulls.update(Object.assign(Object.assign(Object.assign({}, this.context.repo), { 'pull_number': number, base: (yield this.getRefForUpdate(false)).replace(/^heads\//, ''), state: 'open' }), detail));
        });
        /**
         * @param {string} branch branch
         * @return {object} branch info
         */
        this.getBranchInfo = (branch) => {
            const branchName = utils_1.getBranch(branch, false);
            const headName = `heads/${branchName}`;
            const refName = `refs/${headName}`;
            return { branchName, headName, refName };
        };
        /**
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @return {Promise<PullsInfo>} info
         */
        this.createPulls = (createBranchName, detail) => __awaiter(this, void 0, void 0, function* () {
            this.callLogger((logger) => __awaiter(this, void 0, void 0, function* () { return logger.startProcess('Creating PullRequest... [%s] -> [%s]', utils_1.getBranch(createBranchName, false), yield this.getRefForUpdate(false)); }));
            const created = yield this.pullsCreate(createBranchName, detail);
            this.callLogger(logger => logger.endProcess());
            return Object.assign({ isPrCreated: true }, created.data);
        });
        /**
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @return {Promise<PullsInfo>} info
         */
        this.pullsCreateOrUpdate = (createBranchName, detail) => __awaiter(this, void 0, void 0, function* () {
            const pullRequest = yield this.findPullRequest(createBranchName);
            if (pullRequest) {
                this.callLogger((logger) => __awaiter(this, void 0, void 0, function* () { return logger.startProcess('Updating PullRequest... [%s] -> [%s]', utils_1.getBranch(createBranchName, false), yield this.getRefForUpdate(false)); }));
                const updated = yield this.pullsUpdate(pullRequest.number, detail);
                this.callLogger(logger => logger.endProcess());
                return Object.assign({ isPrCreated: false }, updated.data);
            }
            return this.createPulls(createBranchName, detail);
        });
        /**
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @return {Promise<PullsInfo>} info
         */
        this.pullsCreateOrComment = (createBranchName, detail) => __awaiter(this, void 0, void 0, function* () {
            const pullRequest = yield this.findPullRequest(createBranchName);
            if (pullRequest) {
                this.callLogger((logger) => __awaiter(this, void 0, void 0, function* () { return logger.startProcess('Creating comment to PullRequest... [%s] -> [%s]', utils_1.getBranch(createBranchName, false), yield this.getRefForUpdate(false)); }));
                yield this.createCommentToPr(createBranchName, detail.body);
                this.callLogger(logger => logger.endProcess());
                return Object.assign({ isPrCreated: false }, pullRequest);
            }
            return this.createPulls(createBranchName, detail);
        });
        /**
         * @param {string} branch branch
         * @param {string} body body
         * @return {Promise<boolean>} result
         */
        this.createCommentToPr = (branch, body) => __awaiter(this, void 0, void 0, function* () {
            if (!body) {
                return false;
            }
            const pullRequest = yield this.findPullRequest(branch);
            if (!pullRequest) {
                return false;
            }
            yield this.octokit.issues.createComment(Object.assign(Object.assign({}, this.context.repo), { 'issue_number': pullRequest.number, body }));
            return true;
        });
        /**
         * @param {Error} error error
         * @return {boolean} result
         */
        this.isProtectedBranchError = (error) => /required status checks?.* (is|are) expected/i.test(error.message);
        /**
         * @param {string[]} files files
         * @return {boolean} diff?
         */
        this.checkDiff = (files) => {
            if (!files.length) {
                this.callLogger(logger => logger.info('There is no diff.'));
                return false;
            }
            return true;
        };
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {string[]} files files
         * @return {Promise<Octokit.Response<Octokit.GitCreateCommitResponse>>} commit
         */
        this.prepareCommit = (rootDir, commitMessage, files) => __awaiter(this, void 0, void 0, function* () {
            this.callLogger(logger => logger.startProcess('Creating blobs...'));
            const blobs = yield this.filesToBlobs(rootDir, files);
            this.callLogger(logger => logger.startProcess('Creating tree...'));
            const tree = yield this.createTree(blobs);
            this.callLogger(logger => logger.startProcess('Creating commit... [%s]', tree.data.sha));
            return this.createCommit(commitMessage, tree);
        });
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {string[]} files files
         * @return {Promise<boolean>} result
         */
        this.commit = (rootDir, commitMessage, files) => __awaiter(this, void 0, void 0, function* () {
            if (!this.checkDiff(files)) {
                return false;
            }
            const commit = yield this.prepareCommit(rootDir, commitMessage, files);
            const ref = yield this.getRefForUpdate(true);
            this.callLogger(logger => logger.startProcess('Updating ref... [%s] [%s]', ref, commit.data.sha));
            if (yield this.updateRef(commit, ref, false)) {
                process.env.GITHUB_SHA = commit.data.sha;
                core_1.exportVariable('GITHUB_SHA', commit.data.sha);
            }
            this.callLogger(logger => logger.endProcess());
            return true;
        });
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {string[]} files files
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @return {Promise<boolean|PullsInfo>} result
         */
        this.createPR = (rootDir, commitMessage, files, createBranchName, detail) => __awaiter(this, void 0, void 0, function* () {
            if (!this.checkDiff(files)) {
                return false;
            }
            const { branchName, headName, refName } = this.getBranchInfo(createBranchName);
            const commit = yield this.prepareCommit(rootDir, commitMessage, files);
            const ref = yield this.getRef(headName);
            if (null === ref) {
                this.callLogger(logger => logger.startProcess('Creating reference... [%s] [%s]', refName, commit.data.sha));
                yield this.createRef(commit, refName);
            }
            else {
                this.callLogger(logger => logger.startProcess('Updating reference... [%s] [%s]', refName, commit.data.sha));
                yield this.updateRef(commit, headName, true);
            }
            return this.pullsCreateOrUpdate(branchName, detail);
        });
        /**
         * @param {string} createBranchName branch name
         * @param {string} message message
         */
        this.closePR = (createBranchName, message) => __awaiter(this, void 0, void 0, function* () {
            const { branchName, headName, refName } = this.getBranchInfo(createBranchName);
            const pullRequest = yield this.findPullRequest(branchName);
            if (pullRequest) {
                this.callLogger(logger => logger.startProcess('Closing PullRequest... [%s]', branchName));
                if (message) {
                    yield this.createCommentToPr(branchName, message);
                }
                yield this.pullsUpdate(pullRequest.number, {
                    state: 'closed',
                    base: undefined,
                });
            }
            else {
                this.callLogger(logger => logger.info('There is no PullRequest named [%s]', branchName));
                const ref = yield this.getRef(headName);
                if (!ref) {
                    this.callLogger(logger => logger.info('There is no reference named [%s]', refName));
                    return;
                }
            }
            this.callLogger(logger => logger.startProcess('Deleting reference... [%s]', refName));
            yield this.deleteRef(headName);
            this.callLogger(logger => logger.endProcess());
        });
        /**
         * @return {Promise<{ login: string, email: string, name: string, id: number }>} user
         */
        this.getUser = () => __awaiter(this, void 0, void 0, function* () {
            const sender = this.getSender();
            if (false === sender) {
                throw new Error('Sender is not valid.');
            }
            const { data: user } = yield this.octokit.users.getByUsername({
                username: sender,
            });
            return {
                login: user.login,
                email: user.email,
                name: user.name,
                id: user.id,
            };
        });
        /**
         * @return {Promise<string>} default branch
         */
        this.getDefaultBranch = () => __awaiter(this, void 0, void 0, function* () { var _a, _b; return (_b = (_a = this.context.payload.repository) === null || _a === void 0 ? void 0 : _a.default_branch) !== null && _b !== void 0 ? _b : (yield this.octokit.repos.get(Object.assign({}, this.context.repo))).data.default_branch; });
        /**
         * @return {Promise<Array<string>>} tags
         */
        this.getTags = () => __awaiter(this, void 0, void 0, function* () {
            return (yield this.octokit.paginate(this.octokit.git.listMatchingRefs.endpoint.merge(Object.assign(Object.assign({}, this.context.repo), { ref: 'tags/' })))).map((item) => utils_1.trimRef(item.ref));
        });
        /**
         * @return {Promise<string>} tag
         */
        this.getLastTag = () => __awaiter(this, void 0, void 0, function* () { var _c, _d; return 'v' + ((_d = (_c = (yield this.getTags()).filter(tag => /^v?\d+(\.\d+)*$/.test(tag)).sort(utils_1.versionCompare).reverse()[0]) === null || _c === void 0 ? void 0 : _c.replace(/^v/, '')) !== null && _d !== void 0 ? _d : '0.0.0'); });
        /**
         * @return {Promise<string>} tag
         */
        this.getNewPatchVersion = () => __awaiter(this, void 0, void 0, function* () { return utils_1.generateNewPatchVersion(yield this.getLastTag()); });
        this.branch = options === null || options === void 0 ? void 0 : options.branch;
        this.sender = options === null || options === void 0 ? void 0 : options.sender;
        this.refForUpdate = options === null || options === void 0 ? void 0 : options.refForUpdate;
        this.suppressBPError = options === null || options === void 0 ? void 0 : options.suppressBPError;
    }
}
exports.default = ApiHelper;

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("@actions/core");
const utils_1 = require("./utils");
const context_helper_1 = require("./context-helper");
/**
 * API Helper
 */
class ApiHelper {
    /**
     * @param {RestEndpointMethods} octokit octokit
     * @param {Context} context context
     * @param {Logger} logger logger
     * @param {object} options options
     * @param {string|undefined} options.branch branch
     * @param {string|undefined} options.sender sender
     * @param {string|undefined} options.refForUpdate ref for update
     * @param {boolean|undefined} options.suppressBPError suppress branch protection error?
     */
    constructor(octokit, context, logger, options) {
        this.octokit = octokit;
        this.context = context;
        this.logger = logger;
        this.branch = undefined;
        this.sender = undefined;
        this.suppressBPError = undefined;
        this.refForUpdate = undefined;
        this.prCache = {};
        /**
         * @param {OctokitResponse} response response
         * @return {any} data
         */
        this.getResponseData = async (response) => (await response).data;
        /**
         * @param {function} caller caller
         */
        this.callLogger = (caller) => {
            if (this.logger) {
                caller(this.logger);
            }
        };
        /**
         * @return {string|boolean} sender
         */
        this.getSender = () => this.sender ? this.sender : context_helper_1.getSender(this.context);
        /**
         * @param {boolean} encode encode?
         * @return {string} ref for update
         */
        this.getRefForUpdate = async (encode) => {
            const ref = this.refForUpdate ? this.refForUpdate : (utils_1.isPrRef(this.context) ? ('heads/' + (await this.getPR()).head.ref) : utils_1.getRefForUpdate(this.context));
            return encode ? encodeURIComponent(ref) : ref;
        };
        /**
         * @param {string} rootDir root dir
         * @param {string} filepath filepath
         * @return {Promise<{ path: string, sha: string }>} blob
         */
        this.createBlob = async (rootDir, filepath) => {
            const blob = await this.octokit.git.createBlob({
                ...this.context.repo,
                content: Buffer.from(fs_1.default.readFileSync(path_1.default.resolve(rootDir, filepath), 'utf8')).toString('base64'),
                encoding: 'base64',
            });
            return {
                path: filepath,
                sha: blob.data.sha,
            };
        };
        /**
         * @return {string} commit sha
         */
        this.getCommitSha = () => this.context.payload.pull_request ? this.context.payload.pull_request.head.sha : this.context.sha;
        /**
         * @return {Promise<GitGetCommitResponseData>} commit
         */
        this.getCommit = async () => this.getResponseData(this.octokit.git.getCommit({
            ...this.context.repo,
            'commit_sha': this.getCommitSha(),
        }));
        /**
         * @return {Promise<PullsGetResponseData>} commit
         */
        this.getPR = async () => {
            const key = parseInt(this.context.payload.number, 10);
            if (!(key in this.prCache)) {
                this.prCache[key] = await this.getResponseData(this.octokit.pulls.get({
                    ...this.context.repo,
                    'pull_number': this.context.payload.number,
                }));
            }
            return this.prCache[key];
        };
        /**
         * @param {string} rootDir root dir
         * @param {object} files files
         * @return {Promise<Array<{ path: string, sha: string }>>} blobs
         */
        this.filesToBlobs = async (rootDir, files) => await Promise.all(files.map(file => this.createBlob(rootDir, file)));
        /**
         * @param {Array<{ path: string, sha: string }>} blobs blobs
         * @return {Promise<GitCreateTreeResponseData>} tree
         */
        this.createTree = async (blobs) => this.getResponseData(this.octokit.git.createTree({
            ...this.context.repo,
            'base_tree': utils_1.ensureNotNull(utils_1.objectGet((await this.getCommit()), 'tree.sha')),
            tree: blobs.map(blob => ({
                path: blob.path,
                type: 'blob',
                mode: '100644',
                sha: blob.sha,
            })),
        }));
        /**
         * @param {string} commitMessage commit message
         * @param {GitCreateTreeResponseData} tree tree
         * @return {Promise<GitCreateCommitResponseData>} commit
         */
        this.createCommit = async (commitMessage, tree) => this.getResponseData(this.octokit.git.createCommit({
            ...this.context.repo,
            tree: tree.sha,
            parents: [this.getCommitSha()],
            message: commitMessage,
        }));
        /**
         * @param {string} refName refName
         * @return {Promise<GitGetRefResponseData|null>} refName
         */
        this.getRef = async (refName) => {
            try {
                return await this.getResponseData(this.octokit.git.getRef({
                    ...this.context.repo,
                    ref: refName,
                }));
            }
            catch (error) {
                return null;
            }
        };
        /**
         * @param {GitCreateCommitResponseData} commit commit
         * @param {string} refName refName
         * @param {boolean} force force
         * @return {Promise<boolean>} updated?
         */
        this.updateRef = async (commit, refName, force) => {
            try {
                await this.octokit.git.updateRef({
                    ...this.context.repo,
                    ref: refName,
                    sha: utils_1.ensureNotNull(commit.sha),
                    force,
                });
                return true;
            }
            catch (error) {
                if (this.suppressBPError === true && this.isProtectedBranchError(error)) {
                    this.callLogger(logger => logger.warn('Branch is protected.'));
                }
                else {
                    throw error;
                }
                return false;
            }
        };
        /**
         * @param {GitCreateCommitResponseData} commit commit
         * @param {string} refName refName
         * @return {Promise<void>} void
         */
        this.createRef = async (commit, refName) => {
            await this.octokit.git.createRef({
                ...this.context.repo,
                ref: refName,
                sha: utils_1.ensureNotNull(commit.sha),
            });
        };
        /**
         * @param {string} refName refName
         * @return {Promise<void>} void
         */
        this.deleteRef = async (refName) => {
            await this.octokit.git.deleteRef({
                ...this.context.repo,
                ref: refName,
            });
        };
        /**
         * @param {string} branchName branch name
         * @return {Promise<PullsListResponseData | null>} pull request
         */
        this.findPullRequest = async (branchName) => {
            const response = await this.octokit.pulls.list({
                ...this.context.repo,
                head: `${this.context.repo.owner}:${utils_1.getBranch(branchName, false)}`,
            });
            if (response.data.length) {
                return response.data[0];
            }
            return null;
        };
        /**
         * @param {PullsListParams} params params
         * @return {AsyncIterable<Array<PullsListResponseData>>} pull request list
         */
        this.pullsList = (params) => this.octokit.paginate(this.octokit.pulls.list, Object.assign({
            sort: 'created',
            direction: 'asc',
        }, params, {
            ...this.context.repo,
        }));
        /**
         * @param {string} branchName branch name
         * @param {PullsCreateParams} detail detail
         * @return {Promise<PullsCreateResponseData>} pull
         */
        this.pullsCreate = async (branchName, detail) => this.getResponseData(this.octokit.pulls.create({
            ...this.context.repo,
            head: `${this.context.repo.owner}:${utils_1.getBranch(branchName, false)}`,
            base: (await this.getRefForUpdate(false)).replace(/^heads\//, ''),
            ...detail,
        }));
        /**
         * @param {number} number pull number
         * @param {PullsUpdateParams} detail detail
         * @return {Promise<PullsUpdateResponseData>} pull
         */
        this.pullsUpdate = async (number, detail) => this.getResponseData(this.octokit.pulls.update({
            ...this.context.repo,
            'pull_number': number,
            base: (await this.getRefForUpdate(false)).replace(/^heads\//, ''),
            state: 'open',
            ...detail,
        }));
        /**
         * @param {string} branch branch
         * @return {object} branch info
         */
        this.getBranchInfo = (branch) => {
            const branchName = utils_1.getBranch(branch, false);
            const headName = `heads/${branchName}`;
            const refName = `refs/${headName}`;
            return { branchName, headName, refName };
        };
        /**
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @return {Promise<PullsInfo>} info
         */
        this.createPulls = async (createBranchName, detail) => {
            this.callLogger(async (logger) => logger.startProcess('Creating PullRequest... [%s] -> [%s]', utils_1.getBranch(createBranchName, false), await this.getRefForUpdate(false)));
            const created = await this.pullsCreate(createBranchName, detail);
            this.callLogger(logger => logger.endProcess());
            return Object.assign({ isPrCreated: true }, created);
        };
        /**
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @return {Promise<PullsInfo>} info
         */
        this.pullsCreateOrUpdate = async (createBranchName, detail) => {
            const pullRequest = await this.findPullRequest(createBranchName);
            if (pullRequest) {
                this.callLogger(async (logger) => logger.startProcess('Updating PullRequest... [%s] -> [%s]', utils_1.getBranch(createBranchName, false), await this.getRefForUpdate(false)));
                const updated = await this.pullsUpdate(pullRequest.number, detail);
                this.callLogger(logger => logger.endProcess());
                return Object.assign({ isPrCreated: false }, updated);
            }
            return this.createPulls(createBranchName, detail);
        };
        /**
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @return {Promise<PullsInfo>} info
         */
        this.pullsCreateOrComment = async (createBranchName, detail) => {
            const pullRequest = await this.findPullRequest(createBranchName);
            if (pullRequest) {
                this.callLogger(async (logger) => logger.startProcess('Creating comment to PullRequest... [%s] -> [%s]', utils_1.getBranch(createBranchName, false), await this.getRefForUpdate(false)));
                await this.createCommentToPr(createBranchName, detail.body);
                this.callLogger(logger => logger.endProcess());
                return Object.assign({ isPrCreated: false }, pullRequest);
            }
            return this.createPulls(createBranchName, detail);
        };
        /**
         * @param {string} branch branch
         * @param {string} body body
         * @return {Promise<boolean>} result
         */
        this.createCommentToPr = async (branch, body) => {
            if (!body) {
                return false;
            }
            const pullRequest = await this.findPullRequest(branch);
            if (!pullRequest) {
                return false;
            }
            await this.octokit.issues.createComment({
                ...this.context.repo,
                'issue_number': pullRequest.number,
                body,
            });
            return true;
        };
        /**
         * @param {Error} error error
         * @return {boolean} result
         */
        this.isProtectedBranchError = (error) => /required status checks?.* (is|are) expected/i.test(error.message);
        /**
         * @param {Array<string>} files files
         * @return {boolean} diff?
         */
        this.checkDiff = (files) => {
            if (!files.length) {
                this.callLogger(logger => logger.info('There is no diff.'));
                return false;
            }
            return true;
        };
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {Array<string>} files files
         * @return {Promise<GitCreateCommitResponseData>} commit
         */
        this.prepareCommit = async (rootDir, commitMessage, files) => {
            this.callLogger(logger => logger.startProcess('Creating blobs...'));
            const blobs = await this.filesToBlobs(rootDir, files);
            this.callLogger(logger => logger.startProcess('Creating tree...'));
            const tree = await this.createTree(blobs);
            this.callLogger(logger => logger.startProcess('Creating commit... [%s]', tree.sha));
            return this.createCommit(commitMessage, tree);
        };
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {Array<string>} files files
         * @return {Promise<boolean>} result
         */
        this.commit = async (rootDir, commitMessage, files) => {
            if (!this.checkDiff(files)) {
                return false;
            }
            const commit = await this.prepareCommit(rootDir, commitMessage, files);
            const ref = await this.getRefForUpdate(false);
            this.callLogger(logger => logger.startProcess('Updating ref... [%s] [%s]', ref, commit.sha));
            if (await this.updateRef(commit, ref, false)) {
                process.env.GITHUB_SHA = commit.sha;
                core_1.exportVariable('GITHUB_SHA', commit.sha);
            }
            this.callLogger(logger => logger.endProcess());
            return true;
        };
        /**
         * @param {string} rootDir root dir
         * @param {string} commitMessage commit message
         * @param {Array<string>} files files
         * @param {string} createBranchName branch name
         * @param {PullsCreateParams} detail detail
         * @return {Promise<boolean|PullsInfo>} result
         */
        this.createPR = async (rootDir, commitMessage, files, createBranchName, detail) => {
            if (!this.checkDiff(files)) {
                return false;
            }
            const { branchName, headName, refName } = this.getBranchInfo(createBranchName);
            const commit = await this.prepareCommit(rootDir, commitMessage, files);
            const ref = await this.getRef(headName);
            if (null === ref) {
                this.callLogger(logger => logger.startProcess('Creating reference... [%s] [%s]', refName, commit.sha));
                await this.createRef(commit, refName);
            }
            else {
                this.callLogger(logger => logger.startProcess('Updating reference... [%s] [%s]', refName, commit.sha));
                await this.updateRef(commit, headName, true);
            }
            return this.pullsCreateOrUpdate(branchName, detail);
        };
        /**
         * @param {string} createBranchName branch name
         * @param {string} message message
         */
        this.closePR = async (createBranchName, message) => {
            const { branchName, headName, refName } = this.getBranchInfo(createBranchName);
            const pullRequest = await this.findPullRequest(branchName);
            if (pullRequest) {
                this.callLogger(logger => logger.startProcess('Closing PullRequest... [%s]', branchName));
                if (message) {
                    await this.createCommentToPr(branchName, message);
                }
                await this.pullsUpdate(pullRequest.number, {
                    state: 'closed',
                    base: undefined,
                });
            }
            else {
                this.callLogger(logger => logger.info('There is no PullRequest named [%s]', branchName));
                const ref = await this.getRef(headName);
                if (!ref) {
                    this.callLogger(logger => logger.info('There is no reference named [%s]', refName));
                    return;
                }
            }
            this.callLogger(logger => logger.startProcess('Deleting reference... [%s]', refName));
            await this.deleteRef(headName);
            this.callLogger(logger => logger.endProcess());
        };
        /**
         * @return {Promise<{ login: string, email: string, name: string, id: number }>} user
         */
        this.getUser = async () => {
            const sender = this.getSender();
            if (false === sender) {
                throw new Error('Sender is not valid.');
            }
            const { data: user } = await this.octokit.users.getByUsername({
                username: sender,
            });
            return {
                login: user.login,
                email: utils_1.ensureNotNull(user.email),
                name: utils_1.ensureNotNull(user.name),
                id: user.id,
            };
        };
        /**
         * @return {Promise<string>} default branch
         */
        this.getDefaultBranch = async () => { var _a, _b; return (_b = (_a = this.context.payload.repository) === null || _a === void 0 ? void 0 : _a.default_branch) !== null && _b !== void 0 ? _b : (await this.octokit.repos.get({
            ...this.context.repo,
        })).data.default_branch; };
        /**
         * @return {Promise<Array<string>>} tags
         */
        this.getTags = async () => (await this.octokit.paginate(this.octokit.git.listMatchingRefs, {
            ...this.context.repo,
            ref: 'tags/',
        })).map((item) => utils_1.trimRef(item.ref));
        /**
         * @return {Promise<string>} tag
         */
        this.getLastTag = async () => { var _a, _b; return 'v' + ((_b = (_a = (await this.getTags()).filter(tag => /^v?\d+(\.\d+)*$/.test(tag)).sort(utils_1.versionCompare).reverse()[0]) === null || _a === void 0 ? void 0 : _a.replace(/^v/, '')) !== null && _b !== void 0 ? _b : '0.0.0'); };
        /**
         * @return {Promise<string>} tag
         */
        this.getNewPatchVersion = async () => utils_1.generateNewPatchVersion(await this.getLastTag());
        /**
         * @return {Promise<string>} tag
         */
        this.getNewMinorVersion = async () => utils_1.generateNewMinorVersion(await this.getLastTag());
        /**
         * @return {Promise<string>} tag
         */
        this.getNewMajorVersion = async () => utils_1.generateNewMajorVersion(await this.getLastTag());
        this.branch = options === null || options === void 0 ? void 0 : options.branch;
        this.sender = options === null || options === void 0 ? void 0 : options.sender;
        this.refForUpdate = options === null || options === void 0 ? void 0 : options.refForUpdate;
        this.suppressBPError = options === null || options === void 0 ? void 0 : options.suppressBPError;
    }
}
exports.default = ApiHelper;
